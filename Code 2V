import os
import pandas as pd
import oracledb
import re

# Configurações do Oracle Database
ORACLE_USER = "custodia"
ORACLE_PASSWORD = "MVPCustodia2025"
ORACLE_DSN = "localhost:1522/XEPDB1"  # Corrigido: use apenas DSN

# Pasta onde estão os arquivos CSV (altere conforme necessário)
CSV_FOLDER = "C:/Users/thatyane_soares/OneDrive - Sicredi/Documents/Projeto/csv_files"

def find_csv_files(folder_path):
    """Encontra todos os arquivos CSV na pasta especificada"""
    csv_files = []
    try:
        for file in os.listdir(folder_path):
            if file.lower().endswith('.csv'):
                csv_files.append(file)
        print(f"Encontrados {len(csv_files)} arquivos CSV")
        return csv_files
    except Exception as e:
        print(f"Erro ao acessar pasta {folder_path}: {e}")
        return []

def clean_name(name):
    name = str(name).lower().replace(' ', '_')
    name = re.sub(r'[^a-zA-Z0-9_]', '', name)
    name = re.sub(r'_+', '_', name)
    return name.strip('_')

def get_oracle_datatype(dtype, sample_data=None):
    dtype_str = str(dtype)
    
    if 'int' in dtype_str:
        return 'NUMBER'
    elif 'float' in dtype_str:
        return 'NUMBER(15,6)'
    elif 'datetime' in dtype_str:
        return 'DATE'
    elif 'object' in dtype_str:
        if sample_data is not None and hasattr(sample_data, 'str'):
            max_len = sample_data.str.len().max()
            if pd.isna(max_len) or max_len < 1:
                return 'VARCHAR2(500)'
            return f'VARCHAR2({min(int(max_len) * 2, 4000)})'
        return 'VARCHAR2(500)'
    else:
        return 'VARCHAR2(500)'

def df_to_tuples(df):
    """Converte DataFrame para lista de tuplas otimizada para grandes volumes"""
    return [tuple(None if pd.isna(x) else x for x in row) for row in df.itertuples(index=False)]

def test_oracle_connection():
    """Testa a conexão com o Oracle"""
    try:
        connection = oracledb.connect(
            user=ORACLE_USER,
            password=ORACLE_PASSWORD,
            dsn=ORACLE_DSN
        )
        cursor = connection.cursor()
        cursor.execute("SELECT 'Conexão OK' FROM DUAL")
        result = cursor.fetchone()
        print(f"{result[0]}")
        cursor.close()
        connection.close()
        return True
    except Exception as e:
        print(f"Erro na conexão: {e}")
        return False

def import_csv_to_oracle():
    # Verificar se pasta existe
    if not os.path.exists(CSV_FOLDER):
        print(f"Pasta não encontrada: {CSV_FOLDER}")
        return
    
    csv_files = find_csv_files(CSV_FOLDER)
    if not csv_files:
        print("Nenhum CSV encontrado!")
        return

    # Testar conexão primeiro
    if not test_oracle_connection():
        return

    # Conectar ao Oracle
    try:
        connection = oracledb.connect(
            user=ORACLE_USER,
            password=ORACLE_PASSWORD,
            dsn=ORACLE_DSN
        )
        cursor = connection.cursor()
        print("Conectado ao Oracle Database")
    except Exception as e:
        print(f"Erro de conexão: {e}")
        return

    # Processar cada CSV
    for csv_file in csv_files:
        file_path = os.path.join(CSV_FOLDER, csv_file)
        print(f"\n Processando: {csv_file}")

        try:
            # Ler CSV
            try:
                df = pd.read_csv(file_path, low_memory=False)
            except UnicodeDecodeError:
                df = pd.read_csv(file_path, encoding='ISO-8859-1', low_memory=False)
            
            # Verificar se DataFrame não está vazio
            if df.empty:
                print(f"Arquivo vazio: {csv_file}")
                continue

            # Limpar nomes
            table_name = clean_name(csv_file.replace('.csv', ''))
            df.columns = [clean_name(col) for col in df.columns]

            print(f"Linhas: {len(df):,}, Colunas: {len(df.columns)}")

            # Criar schema com tipos mais precisos
            columns_schema = []
            for col in df.columns:
                sample_data = df[col] if df[col].dtype == 'object' else None
                oracle_type = get_oracle_datatype(df[col].dtype, sample_data)
                columns_schema.append(f'"{col}" {oracle_type}')
            
            columns_schema_str = ', '.join(columns_schema)

            # Dropar tabela se existir
            try:
                cursor.execute(f'DROP TABLE "{table_name}"')
                connection.commit()
                print(f"Tabela existente removida: {table_name}")
            except:
                connection.rollback()
                print(f"Criando nova tabela: {table_name}")

            # Criar tabela
            cursor.execute(f'CREATE TABLE "{table_name}" ({columns_schema_str})')
            connection.commit()
            print(f"Tabela criada: {table_name}")

            # Inserir dados em lotes otimizados
            data_tuples = df_to_tuples(df)
            placeholders = ', '.join([':' + str(i+1) for i in range(len(df.columns))])
            insert_sql = f'INSERT INTO "{table_name}" VALUES ({placeholders})'

            # Lotes de 1000 linhas para melhor performance
            batch_size = 1000
            total_rows = len(data_tuples)
            inserted_rows = 0

            for i in range(0, total_rows, batch_size):
                batch = data_tuples[i:i + batch_size]
                try:
                    cursor.executemany(insert_sql, batch, batcherrors=True)
                    connection.commit()
                    inserted_rows += len(batch)
                    progress = min(i + batch_size, total_rows)
                    print(f Progresso: {progress:,}/{total_rows:,} linhas")
                except Exception as batch_error:
                    print(f"Erro no lote: {batch_error}")
                    # Tentar inserir linha por linha
                    successful_in_batch = 0
                    for row in batch:
                        try:
                            cursor.execute(insert_sql, row)
                            successful_in_batch += 1
                        except Exception as row_error:
                            print(f"Erro na linha: {row_error}")
                    connection.commit()
                    inserted_rows += successful_in_batch

            print(f"{csv_file} importado: {inserted_rows:,}/{total_rows:,} linhas")

        except Exception as e:
            print(f"Erro em {csv_file}: {e}")
            connection.rollback()

    cursor.close()
    connection.close()
    print("\nImportação concluída!")

if __name__ == "__main__":
    print("Iniciando importação de CSVs para Oracle...")
    import_csv_to_oracle()
